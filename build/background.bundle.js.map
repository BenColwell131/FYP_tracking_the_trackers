{"version":3,"file":"background.bundle.js","sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/abp-filter-parser/dist/src/abp-filter-parser.js","webpack:///./node_modules/abp-filter-parser/dist/src/badFingerprints.js","webpack:///./node_modules/bloom-filter-js/dist/src/main.js","webpack:///./src/js/background.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js/background.js\");\n","(function (global, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['exports', 'bloom-filter-js', './badFingerprints.js'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports, require('bloom-filter-js'), require('./badFingerprints.js'));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, global.BloomFilterJS, global.badFingerprints);\n    global.abpFilterParser = mod.exports;\n  }\n})(this, function (exports, _bloomFilterJs, _badFingerprintsJs) {\n  'use strict';\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  exports.parseDomains = parseDomains;\n  exports.parseOptions = parseOptions;\n  exports.parseHTMLFilter = parseHTMLFilter;\n  exports.parseFilter = parseFilter;\n  exports.parse = parse;\n  exports.matchesFilter = matchesFilter;\n  exports.matches = matches;\n  exports.getFingerprint = getFingerprint;\n\n  /**\n   * bitwise mask of different request types\n   */\n  var elementTypes = {\n    SCRIPT: 1,\n    IMAGE: 2,\n    STYLESHEET: 4,\n    OBJECT: 8,\n    XMLHTTPREQUEST: 16,\n    OBJECTSUBREQUEST: 32,\n    SUBDOCUMENT: 64,\n    DOCUMENT: 128,\n    OTHER: 256\n  };\n\n  exports.elementTypes = elementTypes;\n  // Maximum number of cached entries to keep for subsequent lookups\n  var maxCached = 100;\n\n  // Maximum number of URL chars to check in match clauses\n  var maxUrlChars = 100;\n\n  // Exact size for fingerprints, if you change also change fingerprintRegexs\n  var fingerprintSize = 8;\n\n  // Regexes used to create fingerprints\n  // There's more than one because sometimes a fingerprint is determined to be a bad\n  // one and would lead to a lot of collisions in the bloom filter). In those cases\n  // we use the 2nd fingerprint.\n  var fingerprintRegexs = [/.*([./&_\\-=a-zA-Z0-9]{8})\\$?.*/, /([./&_\\-=a-zA-Z0-9]{8})\\$?.*/];\n\n  /**\n   * Maps element types to type mask.\n   */\n  var elementTypeMaskMap = new Map([['script', elementTypes.SCRIPT], ['image', elementTypes.IMAGE], ['stylesheet', elementTypes.STYLESHEET], ['object', elementTypes.OBJECT], ['xmlhttprequest', elementTypes.XMLHTTPREQUEST], ['object-subrequest', elementTypes.OBJECTSUBREQUEST], ['subdocument', elementTypes.SUBDOCUMENT], ['document', elementTypes.DOCUMENT], ['other', elementTypes.OTHER]]);\n\n  exports.elementTypeMaskMap = elementTypeMaskMap;\n  var separatorCharacters = ':?/=^';\n\n  /**\n   * Parses the domain string using the passed in separator and\n   * fills in options.\n   */\n\n  function parseDomains(input, separator, options) {\n    options.domains = options.domains || [];\n    options.skipDomains = options.skipDomains || [];\n    var domains = input.split(separator);\n    options.domains = options.domains.concat(domains.filter(function (domain) {\n      return domain[0] !== '~';\n    }));\n    options.skipDomains = options.skipDomains.concat(domains.filter(function (domain) {\n      return domain[0] === '~';\n    }).map(function (domain) {\n      return domain.substring(1);\n    }));\n  }\n\n  /**\n   * Parses options from the passed in input string\n   */\n\n  function parseOptions(input) {\n    var output = {\n      binaryOptions: new Set()\n    };\n    input.split(',').forEach(function (option) {\n      option = option.trim();\n      if (option.startsWith('domain=')) {\n        var domainString = option.split('=')[1].trim();\n        parseDomains(domainString, '|', output);\n      } else {\n        var optionWithoutPrefix = option[0] === '~' ? option.substring(1) : option;\n        if (elementTypeMaskMap.has(optionWithoutPrefix)) {\n          if (option[0] === '~') {\n            output.skipElementTypeMask |= elementTypeMaskMap.get(optionWithoutPrefix);\n          } else {\n            output.elementTypeMask |= elementTypeMaskMap.get(optionWithoutPrefix);\n          }\n        }\n        output.binaryOptions.add(option);\n      }\n    });\n    return output;\n  }\n\n  /**\n   * Finds the first separator character in the input string\n   */\n  function findFirstSeparatorChar(input, startPos) {\n    for (var i = startPos; i < input.length; i++) {\n      if (separatorCharacters.indexOf(input[i]) !== -1) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Parses an HTML filter and modifies the passed in parsedFilterData\n   * as necessary.\n   *\n   * @param input: The entire input string to consider\n   * @param index: Index of the first hash\n   * @param parsedFilterData: The parsedFilterData object to fill\n   */\n\n  function parseHTMLFilter(input, index, parsedFilterData) {\n    var domainsStr = input.substring(0, index);\n    parsedFilterData.options = {};\n    if (domainsStr.length > 0) {\n      parseDomains(domainsStr, ',', parsedFilterData.options);\n    }\n\n    // The XOR parsedFilterData.elementHidingException is in case the rule already\n    // was specified as exception handling with a prefixed @@\n    parsedFilterData.isException = !!(input[index + 1] === '@' ^ parsedFilterData.isException);\n    if (input[index + 1] === '@') {\n      // Skip passed the first # since @# is 2 chars same as ##\n      index++;\n    }\n    parsedFilterData.htmlRuleSelector = input.substring(index + 2);\n  }\n\n  function parseFilter(input, parsedFilterData, bloomFilter, exceptionBloomFilter) {\n    input = input.trim();\n\n    // Check for comment or nothing\n    if (input.length === 0) {\n      return false;\n    }\n\n    // Check for comments\n    var beginIndex = 0;\n    if (input[beginIndex] === '[' || input[beginIndex] === '!') {\n      parsedFilterData.isComment = true;\n      return false;\n    }\n\n    // Check for exception instead of filter\n    parsedFilterData.isException = input[beginIndex] === '@' && input[beginIndex + 1] === '@';\n    if (parsedFilterData.isException) {\n      beginIndex = 2;\n    }\n\n    // Check for element hiding rules\n    var index = input.indexOf('#', beginIndex);\n    if (index !== -1) {\n      if (input[index + 1] === '#' || input[index + 1] === '@') {\n        parseHTMLFilter(input.substring(beginIndex), index - beginIndex, parsedFilterData);\n        // HTML rules cannot be combined with other parsing,\n        // other than @@ exception marking.\n        return true;\n      }\n    }\n\n    // Check for options, regex can have options too so check this before regex\n    index = input.indexOf('$', beginIndex);\n    if (index !== -1) {\n      parsedFilterData.options = parseOptions(input.substring(index + 1));\n      // Get rid of the trailing options for the rest of the parsing\n      input = input.substring(0, index);\n    } else {\n      parsedFilterData.options = {};\n    }\n\n    // Check for a regex\n    parsedFilterData.isRegex = input[beginIndex] === '/' && input[input.length - 1] === '/' && beginIndex !== input.length - 1;\n    if (parsedFilterData.isRegex) {\n      parsedFilterData.data = input.slice(beginIndex + 1, -1);\n      return true;\n    }\n\n    // Check if there's some kind of anchoring\n    if (input[beginIndex] === '|') {\n      // Check for an anchored domain name\n      if (input[beginIndex + 1] === '|') {\n        parsedFilterData.hostAnchored = true;\n        var indexOfSep = findFirstSeparatorChar(input, beginIndex + 1);\n        if (indexOfSep === -1) {\n          indexOfSep = input.length;\n        }\n        beginIndex += 2;\n        parsedFilterData.host = input.substring(beginIndex, indexOfSep);\n      } else {\n        parsedFilterData.leftAnchored = true;\n        beginIndex++;\n      }\n    }\n    if (input[input.length - 1] === '|') {\n      parsedFilterData.rightAnchored = true;\n      input = input.substring(0, input.length - 1);\n    }\n\n    parsedFilterData.data = input.substring(beginIndex) || '*';\n    // Use the host bloom filter if the filter is a host anchored filter rule with no other data\n    if (exceptionBloomFilter && parsedFilterData.isException) {\n      exceptionBloomFilter.add(getFingerprint(parsedFilterData.data));\n    } else if (bloomFilter) {\n      // To check for duplicates\n      //if (bloomFilter.exists(getFingerprint(parsedFilterData.data))) {\n      // console.log('duplicate found for data: ' + getFingerprint(parsedFilterData.data));\n      //}\n      // console.log('parse:', parsedFilterData.data, 'fingerprint:', getFingerprint(parsedFilterData.data));\n      bloomFilter.add(getFingerprint(parsedFilterData.data));\n    }\n\n    return true;\n  }\n\n  /**\n   * Parses the set of filter rules and fills in parserData\n   * @param input filter rules\n   * @param parserData out parameter which will be filled\n   *   with the filters, exceptionFilters and htmlRuleFilters.\n   */\n\n  function parse(input, parserData) {\n    parserData.bloomFilter = parserData.bloomFilter || new _bloomFilterJs.BloomFilter();\n    parserData.exceptionBloomFilter = parserData.exceptionBloomFilter || new _bloomFilterJs.BloomFilter();\n    parserData.filters = parserData.filters || [];\n    parserData.noFingerprintFilters = parserData.noFingerprintFilters || [];\n    parserData.exceptionFilters = parserData.exceptionFilters || [];\n    parserData.htmlRuleFilters = parserData.htmlRuleFilters || [];\n    var startPos = 0;\n    var endPos = input.length;\n    var newline = '\\n';\n    while (startPos <= input.length) {\n      endPos = input.indexOf(newline, startPos);\n      if (endPos === -1) {\n        newline = '\\r';\n        endPos = input.indexOf(newline, startPos);\n      }\n      if (endPos === -1) {\n        endPos = input.length;\n      }\n      var filter = input.substring(startPos, endPos);\n      var parsedFilterData = {};\n      if (parseFilter(filter, parsedFilterData, parserData.bloomFilter, parserData.exceptionBloomFilter)) {\n        var fingerprint = getFingerprint(parsedFilterData.data);\n        if (parsedFilterData.htmlRuleSelector) {\n          parserData.htmlRuleFilters.push(parsedFilterData);\n        } else if (parsedFilterData.isException) {\n          parserData.exceptionFilters.push(parsedFilterData);\n        } else if (fingerprint.length > 0) {\n          parserData.filters.push(parsedFilterData);\n        } else {\n          parserData.noFingerprintFilters.push(parsedFilterData);\n        }\n      }\n      startPos = endPos + 1;\n    }\n  }\n\n  /**\n   * Obtains the domain index of the input filter line\n   */\n  function getDomainIndex(input) {\n    var index = input.indexOf(':');\n    ++index;\n    while (input[index] === '/') {\n      index++;\n    }\n    return index;\n  }\n\n  /**\n   * Similar to str1.indexOf(filter, startingPos) but with\n   * extra consideration to some ABP filter rules like ^.\n   */\n  function indexOfFilter(input, filter, startingPos) {\n    if (filter.length > input.length) {\n      return -1;\n    }\n\n    var filterParts = filter.split('^');\n    var index = startingPos;\n    var beginIndex = -1;\n    var prefixedSeparatorChar = false;\n\n    for (var f = 0; f < filterParts.length; f++) {\n      if (filterParts[f] === '') {\n        prefixedSeparatorChar = true;\n        continue;\n      }\n\n      index = input.indexOf(filterParts[f], index);\n      if (index === -1) {\n        return -1;\n      }\n      if (beginIndex === -1) {\n        beginIndex = index;\n      }\n\n      if (prefixedSeparatorChar) {\n        if (separatorCharacters.indexOf(input[index - 1]) === -1) {\n          return -1;\n        }\n      }\n      // If we are in an in between filterPart\n      if (f + 1 < filterParts.length &&\n      // and we have some chars left in the input past the last filter match\n      input.length > index + filterParts[f].length) {\n        if (separatorCharacters.indexOf(input[index + filterParts[f].length]) === -1) {\n          return -1;\n        }\n      }\n\n      prefixedSeparatorChar = false;\n    }\n    return beginIndex;\n  }\n\n  function getUrlHost(input) {\n    var domainIndexStart = getDomainIndex(input);\n    var domainIndexEnd = findFirstSeparatorChar(input, domainIndexStart);\n    if (domainIndexEnd === -1) {\n      domainIndexEnd = input.length;\n    }\n    return input.substring(domainIndexStart, domainIndexEnd);\n  }\n\n  function filterDataContainsOption(parsedFilterData, option) {\n    return parsedFilterData.options && parsedFilterData.options.binaryOptions && parsedFilterData.options.binaryOptions.has(option);\n  }\n\n  function isThirdPartyHost(baseContextHost, testHost) {\n    if (!testHost.endsWith(baseContextHost)) {\n      return true;\n    }\n\n    var c = testHost[testHost.length - baseContextHost.length - 1];\n    return c !== '.' && c !== undefined;\n  }\n\n  // Determines if there's a match based on the options, this doesn't\n  // mean that the filter rule shoudl be accepted, just that the filter rule\n  // should be considered given the current context.\n  // By specifying context params, you can filter out the number of rules which are\n  // considered.\n  function matchOptions(parsedFilterData, input) {\n    var contextParams = arguments[2] === undefined ? {} : arguments[2];\n\n    if (contextParams.elementTypeMask !== undefined && parsedFilterData.options) {\n      if (parsedFilterData.options.elementTypeMask !== undefined && !(parsedFilterData.options.elementTypeMask & contextParams.elementTypeMask)) {\n        return false;\n      }if (parsedFilterData.options.skipElementTypeMask !== undefined && parsedFilterData.options.skipElementTypeMask & contextParams.elementTypeMask) {\n        return false;\n      }\n    }\n\n    // Domain option check\n    if (contextParams.domain !== undefined && parsedFilterData.options) {\n      if (parsedFilterData.options.domains || parsedFilterData.options.skipDomains) {\n        var _ret = (function () {\n          // Get the domains that should be considered\n          var shouldBlockDomains = parsedFilterData.options.domains.filter(function (domain) {\n            return !isThirdPartyHost(domain, contextParams.domain);\n          });\n\n          var shouldSkipDomains = parsedFilterData.options.skipDomains.filter(function (domain) {\n            return !isThirdPartyHost(domain, contextParams.domain);\n          });\n          // Handle cases like: example.com|~foo.example.com should llow for foo.example.com\n          // But ~example.com|foo.example.com should block for foo.example.com\n          var leftOverBlocking = shouldBlockDomains.filter(function (shouldBlockDomain) {\n            return shouldSkipDomains.every(function (shouldSkipDomain) {\n              return isThirdPartyHost(shouldBlockDomain, shouldSkipDomain);\n            });\n          });\n          var leftOverSkipping = shouldSkipDomains.filter(function (shouldSkipDomain) {\n            return shouldBlockDomains.every(function (shouldBlockDomain) {\n              return isThirdPartyHost(shouldSkipDomain, shouldBlockDomain);\n            });\n          });\n\n          // If we have none left over, then we shouldn't consider this a match\n          if (shouldBlockDomains.length === 0 && parsedFilterData.options.domains.length !== 0 || shouldBlockDomains.length > 0 && leftOverBlocking.length === 0 || shouldSkipDomains.length > 0 && leftOverSkipping.length > 0) {\n            return {\n              v: false\n            };\n          }\n        })();\n\n        if (typeof _ret === 'object') return _ret.v;\n      }\n    }\n\n    // If we're in the context of third-party site, then consider third-party option checks\n    if (contextParams['third-party'] !== undefined) {\n      // Is the current rule check for third party only?\n      if (filterDataContainsOption(parsedFilterData, 'third-party')) {\n        var inputHost = getUrlHost(input);\n        var inputHostIsThirdParty = isThirdPartyHost(parsedFilterData.host, inputHost);\n        if (inputHostIsThirdParty || !contextParams['third-party']) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Given an individual parsed filter data determines if the input url should block.\n   */\n\n  function matchesFilter(parsedFilterData, input) {\n    var contextParams = arguments[2] === undefined ? {} : arguments[2];\n    var cachedInputData = arguments[3] === undefined ? {} : arguments[3];\n\n    if (!matchOptions(parsedFilterData, input, contextParams)) {\n      return false;\n    }\n\n    // Check for a regex match\n    if (parsedFilterData.isRegex) {\n      if (!parsedFilterData.regex) {\n        parsedFilterData.regex = new RegExp(parsedFilterData.data);\n      }\n      return parsedFilterData.regex.test(input);\n    }\n\n    // Check for both left and right anchored\n    if (parsedFilterData.leftAnchored && parsedFilterData.rightAnchored) {\n      return parsedFilterData.data === input;\n    }\n\n    // Check for right anchored\n    if (parsedFilterData.rightAnchored) {\n      return input.slice(-parsedFilterData.data.length) === parsedFilterData.data;\n    }\n\n    // Check for left anchored\n    if (parsedFilterData.leftAnchored) {\n      return input.substring(0, parsedFilterData.data.length) === parsedFilterData.data;\n    }\n\n    // Check for domain name anchored\n    if (parsedFilterData.hostAnchored) {\n      if (!cachedInputData.currentHost) {\n        cachedInputData.currentHost = getUrlHost(input);\n      }\n\n      return !isThirdPartyHost(parsedFilterData.host, cachedInputData.currentHost) && indexOfFilter(input, parsedFilterData.data) !== -1;\n    }\n\n    // Wildcard match comparison\n    var parts = parsedFilterData.data.split('*');\n    var index = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var part = _step.value;\n\n        var newIndex = indexOfFilter(input, part, index);\n        if (newIndex === -1) {\n          return false;\n        }\n        index = newIndex + part.length;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator['return']) {\n          _iterator['return']();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function discoverMatchingPrefix(array, bloomFilter, str) {\n    var prefixLen = arguments[3] === undefined ? fingerprintSize : arguments[3];\n\n    for (var i = 0; i < str.length - prefixLen + 1; i++) {\n      var sub = str.substring(i, i + prefixLen);\n      if (bloomFilter.exists(sub)) {\n        array.push({ badFingerprint: sub, src: str });\n        // console.log('bad-fingerprint:', sub, 'for url:', str);\n      } else {}\n    }\n  }\n\n  function hasMatchingFilters(filterList, parsedFilterData, input, contextParams, cachedInputData) {\n    return filterList.some(function (parsedFilterData) {\n      return matchesFilter(parsedFilterData, input, contextParams, cachedInputData);\n    });\n  }\n\n  /**\n   * Using the parserData rules will try to see if the input URL should be blocked or not\n   * @param parserData The filter data obtained from a call to parse\n   * @param input The input URL\n   * @return true if the URL should be blocked\n   */\n\n  function matches(parserData, input) {\n    var contextParams = arguments[2] === undefined ? {} : arguments[2];\n    var cachedInputData = arguments[3] === undefined ? {} : arguments[3];\n\n    cachedInputData.bloomNegativeCount = cachedInputData.bloomNegativeCount || 0;\n    cachedInputData.bloomPositiveCount = cachedInputData.bloomPositiveCount || 0;\n    cachedInputData.notMatchCount = cachedInputData.notMatchCount || 0;\n    cachedInputData.badFingerprints = cachedInputData.badFingerprints || [];\n    cachedInputData.bloomFalsePositiveCount = cachedInputData.bloomFalsePositiveCount || 0;\n    var hasMatchingNoFingerprintFilters = undefined;\n    var cleanedInput = input.replace(/^https?:\\/\\//, '');\n    if (cleanedInput.length > maxUrlChars) {\n      cleanedInput = cleanedInput.substring(0, maxUrlChars);\n    }\n    if (parserData.bloomFilter) {\n      if (!parserData.bloomFilter.substringExists(cleanedInput, fingerprintSize)) {\n        cachedInputData.bloomNegativeCount++;\n        cachedInputData.notMatchCount++;\n        // console.log('early return because of bloom filter check!');\n        hasMatchingNoFingerprintFilters = hasMatchingFilters(parserData.noFingerprintFilters, parserData, input, contextParams, cachedInputData);\n\n        if (!hasMatchingNoFingerprintFilters) {\n          return false;\n        }\n      }\n      // console.log('looked for url in bloom filter and it said yes:', cleaned);\n    }\n    cachedInputData.bloomPositiveCount++;\n\n    // console.log('not early return: ', input);\n    delete cachedInputData.currentHost;\n    cachedInputData.misses = cachedInputData.misses || new Set();\n    cachedInputData.missList = cachedInputData.missList || [];\n    if (cachedInputData.missList.length > maxCached) {\n      cachedInputData.misses['delete'](cachedInputData.missList[0]);\n      cachedInputData.missList = cachedInputData.missList.splice(1);\n    }\n    if (cachedInputData.misses.has(input)) {\n      cachedInputData.notMatchCount++;\n      // console.log('positive match for input: ', input);\n      return false;\n    }\n\n    if (hasMatchingFilters(parserData.filters, parserData, input, contextParams, cachedInputData) || hasMatchingNoFingerprintFilters === true || hasMatchingNoFingerprintFilters === undefined && hasMatchingFilters(parserData.noFingerprintFilters, parserData, input, contextParams, cachedInputData)) {\n      // Check for exceptions only when there's a match because matches are\n      // rare compared to the volume of checks\n      var exceptionBloomFilterMiss = parserData.exceptionBloomFilter && !parserData.exceptionBloomFilter.substringExists(cleanedInput, fingerprintSize);\n      if (!exceptionBloomFilterMiss || hasMatchingFilters(parserData.exceptionFilters, parserData, input, contextParams, cachedInputData)) {\n        cachedInputData.notMatchCount++;\n        return false;\n      }\n      return true;\n    }\n\n    // The bloom filter had a false positive, se we checked for nothing! :'(\n    // This is probably (but not always) an indication that the fingerprint selection should be tweaked!\n    cachedInputData.missList.push(input);\n    cachedInputData.misses.add(input);\n    cachedInputData.notMatchCount++;\n    cachedInputData.bloomFalsePositiveCount++;\n    discoverMatchingPrefix(cachedInputData.badFingerprints, parserData.bloomFilter, cleanedInput);\n    // console.log('positive match for input: ', input);\n    return false;\n  }\n\n  /**\n   * Obtains a fingerprint for the specified filter\n   */\n\n  function getFingerprint(_x7) {\n    var _again = true;\n\n    _function: while (_again) {\n      var str = _x7;\n      _loop = i = _ret2 = undefined;\n      _again = false;\n\n      var _loop = function () {\n        var fingerprintRegex = fingerprintRegexs[i];\n        var result = fingerprintRegex.exec(str);\n        fingerprintRegex.lastIndex = 0;\n\n        if (result && !_badFingerprintsJs.badFingerprints.includes(result[1]) && !_badFingerprintsJs.badSubstrings.find(function (badSubstring) {\n          return result[1].includes(badSubstring);\n        })) {\n          return {\n            v: result[1]\n          };\n        }\n        if (result) {} else {}\n      };\n\n      for (var i = 0; i < fingerprintRegexs.length; i++) {\n        var _ret2 = _loop();\n\n        if (typeof _ret2 === 'object') return _ret2.v;\n      }\n      // This is pretty ugly but getting fingerprints is assumed to be used only when preprocessing and\n      // in a live environment.\n      if (str.length > 8) {\n        // Remove first and last char\n        _x7 = str.slice(1, -1);\n        _again = true;\n        continue _function;\n      }\n      // console.warn('Warning: Could not determine a good fingerprint for:', str);\n      return '';\n    }\n  }\n});\n\n// console.log('good-fingerprint:', sub, 'for url:', str);\n\n// console.log('checking again for str:', str, 'result:', result[1]);\n\n// console.log('checking again for str, no result');\n//# sourceMappingURL=abp-filter-parser.js.map","(function (global, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports);\n    global.badFingerprints = mod.exports;\n  }\n})(this, function (exports) {\n  'use strict';\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  var badFingerprints = ['/google/', 'optimize', '/widget.', 'load.php', '95d2-d38', 'googleta', 'storage.', 'callback', 'leclick.', 'default_', 'lacement', '/assets/', 's/skins/', '/themes/', '-loader-', '/header-', '/public/', 'default/', 'd/jsonp/', 'gallery-', 'k/widget', '-curve-m', 'eloader/', 'tooltip/', '/footer/', '/footer-', 'oogletag', 'google.c', 'uv_I-qM8', 'oogle.co', 'ogletags', 'bleclick', 'gletagse', 'letagser', 'eclick.n', 'click.ne', 'googlesy', 'ooglesyn', 'arousel/', 'm-0.0.12', 'gallery/', 'es-heade', '-header-', 'message.', 'Callback', 'channel=', 'onp/pid=', 'ayer.swf', 'include.', 'amazonaw', 'allback&', 's/client', 'article_', '79942%22', 'allback_', '_wrapper', 'wrapper.', 'm/tools/', 'takeover', '_bottom_', 'mponent/', 'ference/', 's/index.', 'ebottom.', '&domain=', 'atic/js/', 'ad_type=', 'u4eSmzTp', 'ign=null', 'aterial.', '/upload/', 'amazon.c', 'b50c29dd', 'dformat=', 'rvices.c', 'eywords=', '2n%22:0,', 'C&v=404&', 'mazon.co', 'vices.co', 's/views/', 'hardware', 'es-heade'];\n  exports.badFingerprints = badFingerprints;\n  var badSubstrings = ['com', 'net', 'http', 'image', 'www', 'img', '.js', 'oogl', 'min.', 'que', 'synd', 'dicat', 'templ', 'tube', 'page', 'home', 'mepa', 'mplat', 'tati', 'user', 'aws', 'omp', 'icros', 'espon', 'org', 'nalyti', 'acebo', 'lead', 'con', 'count', 'vers', 'pres', 'aff', 'atio', 'tent', 'ative', 'en_', 'fr_', 'es_', 'ha1', 'ha2', 'live', 'odu', 'esh', 'adm', 'crip', 'ect', 'tics', 'edia', 'ini', 'yala', 'ana', 'rac', 'trol', 'tern', 'card', 'yah', 'tion', 'erv', '.co', 'lug', 'eat', 'ugi', 'ates', 'loud', 'ner', 'earc', 'atd', 'fro', 'ruct', 'sour', 'news', 'ddr', 'htm', 'fram', 'dar', 'flas', 'lay', 'orig', 'uble', 'om/', 'ext', 'link', '.png', 'com/', 'tri', 'but', 'vity', 'spri'];\n  exports.badSubstrings = badSubstrings;\n});\n//# sourceMappingURL=badFingerprints.js.map","(function (global, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports);\n    global.main = mod.exports;\n  }\n})(this, function (exports) {\n  'use strict';\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n\n  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n  var toCharCodeArray = function toCharCodeArray(str) {\n    return str.split('').map(function (c) {\n      return c.charCodeAt(0);\n    });\n  };\n\n  exports.toCharCodeArray = toCharCodeArray;\n  /**\n   * Returns a function that generates a Rabin fingerprint hash function\n   * @param p The prime to use as a base for the Rabin fingerprint algorithm\n   */\n  var simpleHashFn = function simpleHashFn(p) {\n    return function (arrayValues, lastHash, lastCharCode) {\n      return lastHash ?\n      // See the abracadabra example: https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm\n      (lastHash - lastCharCode * Math.pow(p, arrayValues.length - 1)) * p + arrayValues[arrayValues.length - 1] : arrayValues.reduce(function (total, x, i) {\n        return total + x * Math.pow(p, arrayValues.length - i - 1);\n      }, 0);\n    };\n  };\n\n  exports.simpleHashFn = simpleHashFn;\n  /*\n   * Sets the specific bit location\n   */\n  var setBit = function setBit(buffer, bitLocation) {\n    return buffer[bitLocation / 8 | 0] |= 1 << bitLocation % 8;\n  };\n\n  exports.setBit = setBit;\n  /**\n   * Returns true if the specified bit location is set\n   */\n  var isBitSet = function isBitSet(buffer, bitLocation) {\n    return !!(buffer[bitLocation / 8 | 0] & 1 << bitLocation % 8);\n  };\n\n  exports.isBitSet = isBitSet;\n\n  var BloomFilter = (function () {\n    /**\n     * Constructs a new BloomFilter instance.\n     * If you'd like to initialize with a specific size just call BloomFilter.from(Array.from(Uint8Array(size).values()))\n     * Note that there is purposely no remove call because adding that would introduce false negatives.\n     *\n     * @param bitsPerElement Used along with estimatedNumberOfElements to figure out the size of the BloomFilter\n     *   By using 10 bits per element you'll have roughly 1% chance of false positives.\n     * @param estimatedNumberOfElements Used along with bitsPerElementto figure out the size of the BloomFilter\n     * @param hashFns An array of hash functions to use. These can be custom but they should be of the form\n     *   (arrayValues, lastHash, lastCharCode) where the last 2 parameters are optional and are used to make\n     *   a rolling hash to save computation.\n     */\n\n    function BloomFilter(bitsPerElement, estimatedNumberOfElements, hashFns) {\n      if (bitsPerElement === undefined) bitsPerElement = 10;\n      if (estimatedNumberOfElements === undefined) estimatedNumberOfElements = 50000;\n\n      _classCallCheck(this, BloomFilter);\n\n      if (bitsPerElement.constructor === Uint8Array) {\n        // Re-order params\n        this.buffer = bitsPerElement;\n        if (estimatedNumberOfElements.constructor === Array) {\n          hashFns = estimatedNumberOfElements;\n        }\n        // Calculate new buffer size\n        this.bufferBitSize = this.buffer.length * 8;\n      } else if (bitsPerElement.constructor === Array) {\n        // Re-order params\n        var arrayLike = bitsPerElement;\n        if (estimatedNumberOfElements.constructor === Array) {\n          hashFns = estimatedNumberOfElements;\n        }\n        // Calculate new buffer size\n        this.bufferBitSize = arrayLike.length * 8;\n        this.buffer = new Uint8Array(arrayLike);\n      } else {\n        // Calculate the needed buffer size in bytes\n        this.bufferBitSize = bitsPerElement * estimatedNumberOfElements;\n        this.buffer = new Uint8Array(Math.ceil(this.bufferBitSize / 8));\n      }\n      this.hashFns = hashFns || [simpleHashFn(11), simpleHashFn(17), simpleHashFn(23)];\n      this.setBit = setBit.bind(this, this.buffer);\n      this.isBitSet = isBitSet.bind(this, this.buffer);\n    }\n\n    _createClass(BloomFilter, [{\n      key: 'toJSON',\n\n      /**\n       * Serializing the current BloomFilter into a JSON friendly format.\n       * You would typically pass the result into JSON.stringify.\n       * Note that BloomFilter.from only works if the hash functions are the same.\n       */\n      value: function toJSON() {\n        return Array.from(this.buffer.values());\n      }\n    }, {\n      key: 'print',\n\n      /**\n       * Print the buffer, mostly used for debugging only\n       */\n      value: function print() {\n        console.log(this.buffer);\n      }\n    }, {\n      key: 'getLocationsForCharCodes',\n\n      /**\n       * Given a string gets all the locations to check/set in the buffer\n       * for that string.\n       * @param charCodes An array of the char codes to use for the hash\n       */\n      value: function getLocationsForCharCodes(charCodes) {\n        var _this = this;\n\n        return this.hashFns.map(function (h) {\n          return h(charCodes) % _this.bufferBitSize;\n        });\n      }\n    }, {\n      key: 'getHashesForCharCodes',\n\n      /**\n       * Obtains the hashes for the specified charCodes\n       * See \"Rabin fingerprint\" in https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm for more information.\n       *\n       * @param charCodes An array of the char codes to use for the hash\n       * @param lastHashes If specified, it will pass the last hash to the hashing\n       * function for a faster computation.  Must be called with lastCharCode.\n       * @param lastCharCode if specified, it will pass the last char code\n       *  to the hashing function for a faster computation. Must be called with lastHashes.\n       */\n      value: function getHashesForCharCodes(charCodes, lastHashes, lastCharCode) {\n        var _this2 = this;\n\n        return this.hashFns.map(function (h, i) {\n          return h(charCodes, lastHashes ? lastHashes[i] : undefined, lastCharCode, _this2.bufferBitSize);\n        });\n      }\n    }, {\n      key: 'add',\n\n      /**\n       * Adds he specified string to the set\n       */\n      value: function add(data) {\n        if (data.constructor !== Array) {\n          data = toCharCodeArray(data);\n        }\n\n        this.getLocationsForCharCodes(data).forEach(this.setBit);\n      }\n    }, {\n      key: 'exists',\n\n      /**\n       * Checks whether an element probably exists in the set, or definitely doesn't.\n       * @param str Either a string to check for existance or an array of the string's char codes\n       *   The main reason why you'd want to pass in a char code array is because passing a string\n       *   will use JS directly to get the char codes which is very inneficient compared to calling\n       *   into C++ code to get it and then making the call.\n       *\n       * Returns true if the element probably exists in the set\n       * Returns false if the element definitely does not exist in the set\n       */\n      value: function exists(data) {\n        if (data.constructor !== Array) {\n          data = toCharCodeArray(data);\n        }\n        return this.getLocationsForCharCodes(data).every(this.isBitSet);\n      }\n    }, {\n      key: 'substringExists',\n\n      /**\n       * Checks if any substring of length substringLenght probably exists or definitely doesn't\n       * If false is returned then no substring of the specified string of the specified lengthis in the bloom filter\n       * @param data The substring or char array to check substrings on.\n       */\n      value: function substringExists(data, substringLength) {\n        var _this3 = this;\n\n        if (data.constructor !== Uint8Array) {\n          if (data.constructor !== Array) {\n            data = toCharCodeArray(data);\n          }\n          data = new Uint8Array(data);\n        }\n\n        var lastHashes = undefined,\n            lastCharCode = undefined;\n        for (var i = 0; i < data.length - substringLength + 1; i++) {\n\n          lastHashes = this.getHashesForCharCodes(data.subarray(i, i + substringLength), lastHashes, lastCharCode);\n          if (lastHashes.map(function (x) {\n            return x % _this3.bufferBitSize;\n          }).every(this.isBitSet)) {\n            return true;\n          }\n          lastCharCode = data[i];\n        }\n        return false;\n      }\n    }], [{\n      key: 'from',\n\n      /**\n       * Construct a Bloom filter from a previous array of data\n       * Note that the hash functions must be the same!\n       */\n      value: function from(arrayLike, hashFns) {\n        return new BloomFilter(arrayLike, hashFns);\n      }\n    }]);\n\n    return BloomFilter;\n  })();\n\n  exports.BloomFilter = BloomFilter;\n});\n//# sourceMappingURL=main.js.map","// Imports\r\nlet ABPFilterParser = require('abp-filter-parser');\r\n\r\n// Global variables\r\nlet numWS = 0;\r\nlet numWSSent = 0;\r\nlet numWSReceived = 0;\r\nlet numBlockableWS = 0;\r\n\r\nlet parsedFilterList = {};\r\n\r\nfunction updatePopup(){\r\n  chrome.runtime.sendMessage({\r\n    type: \"POPUP_UPDATE\",\r\n    numWS: numWS,\r\n    numWSSent: numWSSent,\r\n    numWSReceived: numWSReceived,\r\n    numBlockableWS: numBlockableWS\r\n  });\r\n}\r\n\r\nfunction fetchFilterLists(){\r\n  console.time(\"Fetching lists & parsing\");\r\n  let easyprivacyURL = chrome.runtime.getURL('assets/filters/easyprivacy.txt');\r\n  const fetch1 = fetch(easyprivacyURL).then(response => response.text());\r\n\r\n  let easylistURL = chrome.runtime.getURL('assets/filters/easylist.txt');\r\n  const fetch2 = fetch(easylistURL).then(response => response.text());\r\n\r\n  Promise.all([fetch1, fetch2])\r\n    .then(filterLists => {\r\n      //Add each list to the parsed list\r\n      filterLists.forEach(filterList => {\r\n        ABPFilterParser.parse(filterList, parsedFilterList);\r\n      });\r\n      console.timeEnd(\"Fetching lists & parsing\");\r\n    })\r\n    .catch(err => console.log(err));\r\n}\r\n//TODO: not sure when this should be called.\r\nfetchFilterLists();\r\n\r\nfunction filterURL(wsURL){\r\n      // Check Websocket URL against our lists.\r\n      let wsURLString = wsURL.toString();\r\n      console.time(\"Filter matching\");\r\n      if (ABPFilterParser.matches(parsedFilterList, wsURLString, {\r\n        // domain: //TODO\r\n        elementTypeMask: ABPFilterParser.elementTypes.SCRIPT\r\n      })) {\r\n        console.log(\"Matched URL to list. You should block this URL!\");\r\n      }\r\n      else {\r\n        console.log(\"Didn't match URL to list. Safe to proceed.\");\r\n      }\r\n      console.timeEnd(\"Filter matching\");\r\n}\r\n\r\nfunction checkFirstPartyURL(wsURL){\r\n    return new Promise((resolve, reject) => {\r\n      console.log(\"Checking WS url: \" + wsURL);\r\n\r\n      //Fetch tab url\r\n      let tabURL;\r\n      chrome.tabs.query({'active': true, 'currentWindow': true}, function(tabs){\r\n        tabURL = tabs[0].url;\r\n        // Convert to URL object for easy parsing.\r\n        tabURL = new URL(tabURL);\r\n\r\n        console.log(\"wsURL.hostname: \" + wsURL.hostname);\r\n        console.log(\"tabURL.hostname: \" + tabURL.hostname);\r\n        if(wsURL.hostname != tabURL.hostname){\r\n          console.log(\"Third Party WS Connection. Caution!\");\r\n        }\r\n        else if (wsURL.hostname === tabURL.hostname){\r\n          console.log(\"First Party WS Connection. Safe to proceed.\");\r\n        }\r\n\r\n        resolve('End of tabs.query');\r\n      });\r\n    });\r\n}\r\n\r\nchrome.runtime.onMessage.addListener(\r\n  (message, sender, sendResponse) => {\r\n    // Checks if one of our messages.\r\n    if(message.type){\r\n      switch(message.type){\r\n        case \"NEW_WS\":\r\n          if(numWS === 0){\r\n            // Alter UI Badge\r\n            chrome.browserAction.setBadgeText({text: '!'});\r\n            chrome.browserAction.setBadgeBackgroundColor({color: '#2aa4ff'});\r\n          }\r\n          numWS++;\r\n          console.log(\"New WS opened.\");\r\n\r\n          // Convert to URL object for easy parsing.\r\n          let wsURL = new URL(message.url);\r\n          checkFirstPartyURL(wsURL)\r\n            .then(filterURL(wsURL));\r\n\r\n          break;\r\n\r\n        case \"WS_FRAME_SENT\":\r\n          numWSSent++;\r\n          // console.log(\"WS frame sent. #\" + numWSSent);\r\n          break;\r\n\r\n        case \"WS_FRAME_RECIEVED\":\r\n          numWSReceived++;\r\n          // console.log(\"WS frame received. #\" + numWSReceived);\r\n          break;\r\n\r\n        case \"WS_CLOSED\":\r\n          if(numWS === 1){\r\n            // Alter UI Badge\r\n            chrome.browserAction.setBadgeText({text: ''});\r\n          }\r\n          numWS--;\r\n          console.log(\"WS Closed.\");\r\n          break;\r\n\r\n        case \"UPDATE_POPUP\":\r\n          // Done by default in all cases so nothing to do here.\r\n          break;\r\n\r\n        default:\r\n          console.log(\"Uncaught message type in background: \" + message);\r\n      }\r\n      updatePopup();\r\n    }\r\n  }\r\n);\r\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AAAA;AAAA;AAAA;AACA,qBAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1oBA;AACA;AACA;AAAA;AAAA;AAAA;AACA,qBAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvBA;AACA;AACA;AAAA;AAAA;AAAA;AACA,qBAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}